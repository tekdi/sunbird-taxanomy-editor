import { useFrameworkFormStore } from '@/store/frameworkFormStore';
import { useFrameworksStore } from '@/store/frameworksStore';

export interface SimulateApiResponse {
  url: string;
  method: string;
  data?: unknown;
  status: number;
}

export async function simulateApiCall(
  url: string,
  method: string,
  data?: unknown
): Promise<SimulateApiResponse> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve({ url, method, data, status: 200 });
    }, 600);
  });
}

// Formats a date (string or Date object) into a readable string like "Jan 01, 2024".
export function formatDate(date: Date | string) {
  const d = new Date(date);
  const months = [
    'Jan',
    'Feb',
    'Mar',
    'Apr',
    'May',
    'Jun',
    'Jul',
    'Aug',
    'Sep',
    'Oct',
    'Nov',
    'Dec',
  ];
  const month = months[d.getMonth()];
  const day = String(d.getDate()).padStart(2, '0');
  const year = d.getFullYear();
  return `${month} ${day}, ${year}`;
}

// Converts a string to camelCase, removing non-alphanumeric separators and capitalizing the following letter.
export function camelCaseCode(input: string): string {
  // If the input contains spaces, use the existing camelCase logic
  if (/\s/.test(input)) {
    return input
      .replace(/[-_\s]+(.)?/g, (_match, chr) => (chr ? chr.toUpperCase() : ''))
      .replace(/^[A-Z]/, (match) => match.toLowerCase());
  }

  // If the input is a single word (no spaces)
  // Check if all letters are uppercase (ignore numbers)
  const lettersOnly = input.replace(/[^A-Za-z]/g, '');
  if (lettersOnly && lettersOnly === lettersOnly.toUpperCase()) {
    return input.toLowerCase();
  }

  // Otherwise, use the existing camelCase logic
  return input
    .replace(/[-_\s]+(.)?/g, (_match, chr) => (chr ? chr.toUpperCase() : ''))
    .replace(/^[A-Z]/, (match) => match.toLowerCase());
}

// Checks if a string is in camelCase format
export function isCamelCase(input: string): boolean {
  // CamelCase pattern: starts with lowercase letter, followed by alphanumeric characters
  // with optional uppercase letters in between
  const camelCasePattern = /^[a-z][a-zA-Z0-9]*$/;
  return camelCasePattern.test(input);
}

// Returns a copy of the given object with the name updated and the code (or custom code field) auto-generated in camelCase from the name.
export function autoFillCodeFromName<T extends { name: string; code: string }>(
  obj: T,
  name: string,
  codeField?: 'code' | string
): T {
  const codeKey = codeField || 'code';
  return {
    ...obj,
    name,
    [codeKey]: camelCaseCode(name),
  };
}

// Returns the name as the description (currently a pass-through, but can be extended).
export function autoGenerateDescriptionFromName(name: string): string {
  return name;
}

// Publishes a framework after any edit operation
export async function publishFramework(
  frameworkCode: string,
  channelId: string
): Promise<unknown> {
  // Add a 500ms delay before publishing
  await new Promise((res) => setTimeout(res, 500));
  const tenantId = process.env.NEXT_PUBLIC_TENANT_ID;
  const authToken = process.env.NEXT_PUBLIC_AUTH_TOKEN;
  const cookie = process.env.NEXT_PUBLIC_COOKIE;
  const interfaceUrl = process.env.NEXT_PUBLIC_INTERFACE_URL;

  if (!tenantId || !authToken || !cookie || !interfaceUrl) {
    throw new Error('Missing environment variables');
  }

  const myHeaders = new Headers();
  myHeaders.append('tenantId', tenantId);
  myHeaders.append('X-Channel-Id', channelId);
  myHeaders.append('Authorization', `Bearer ${authToken}`);
  myHeaders.append('Cookie', cookie);

  const requestOptions = {
    method: 'POST',
    headers: myHeaders,
    redirect: 'follow' as RequestRedirect,
  };

  const url = `${interfaceUrl}/api/framework/v1/publish/${frameworkCode}`;

  try {
    const response = await fetch(url, requestOptions);

    if (!response.ok) {
      let errorMessage: string;

      // Handle specific HTTP status codes
      switch (response.status) {
        case 401:
          errorMessage =
            'Authorization failed. Please check your credentials and try again.';
          break;
        case 403:
          errorMessage =
            'Access forbidden. You do not have permission to publish this framework.';
          break;
        case 404:
          errorMessage =
            'Framework not found. Please check the framework code and try again.';
          break;
        case 500:
          errorMessage =
            'Server error occurred while publishing framework. Please try again later.';
          break;
        default:
          errorMessage = `Failed to publish framework (Status: ${response.status})`;
      }

      // Try to get error details from response
      try {
        const errorData = await response.json();
        if (errorData?.params?.errmsg) {
          errorMessage = errorData.params.errmsg;
        } else if (errorData?.message) {
          errorMessage = errorData.message;
        }
      } catch {
        // If response is not JSON, use the status-based message
      }

      throw new Error(errorMessage);
    }

    const result = await response.text();
    console.log('Publish result:', result);
    return result;
  } catch (error) {
    if (error instanceof Error) {
      console.error('Publish error:', error.message);
      throw error;
    }
    console.error('Publish error:', error);
    throw new Error('An unexpected error occurred while publishing framework');
  }
}

// Publishes a framework after batch operations (categories, terms, associations)
// Handles channelId resolution from stores and error handling
export async function publishFrameworkAfterBatchOperation(
  frameworkCode: string,
  operationType: string,
  channelId?: string
): Promise<{ success: boolean; error?: string }> {
  try {
    // Try to get channelId from argument first, then from stores
    let resolvedChannelId = channelId;
    if (!resolvedChannelId) {
      const framework = useFrameworkFormStore.getState().framework;
      const frameworks = useFrameworksStore.getState().frameworks;

      if (framework?.channel) {
        resolvedChannelId = framework.channel;
      } else {
        const currentFramework = frameworks.find(
          (fw) => fw.code === frameworkCode
        );
        resolvedChannelId = currentFramework?.channel;
      }
    }

    if (resolvedChannelId) {
      await publishFramework(frameworkCode, resolvedChannelId);
      return { success: true };
    } else {
      const errorMsg = `No channelId found for framework ${frameworkCode}`;
      console.warn(
        `Failed to publish framework after batch ${operationType}:`,
        errorMsg
      );
      return { success: false, error: errorMsg };
    }
  } catch (publishError) {
    const errorMsg =
      publishError instanceof Error ? publishError.message : 'Unknown error';
    console.warn(
      `Failed to publish framework after batch ${operationType}:`,
      publishError
    );
    return { success: false, error: errorMsg };
  }
}
